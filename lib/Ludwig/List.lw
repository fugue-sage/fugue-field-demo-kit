@language("no-prelude")

import Ludwig.Error as .
import Ludwig.Int as .

export
    null
    length
    head
    tail
    cons
    uncons
    concat
    fold
    fold1
    map
    filter
    cartesian-product
    take
    drop
    elementAt
    any
    all
    safeElementAt
    equal
    intersperse

# Return the length of the specified `List`.
#
# Example:
#
#     my-len: length([1, 2, 3])   # => 3
fun length(xs: List<a>) -> Int: __Ludwig_List_length(xs)

# Concatenate two `List`s and return the resulting `List`.
#
# Example:
#
#     my-list: concat([1, 2], [3, 4])   # => [1, 2, 3, 4]
fun concat(x: List<a>, y: List<a>) -> List<a>: __Ludwig_List_concat(x, y)

# Returns the first element of the `List` wrapped in an
# `Optional`. Returns `None` if the `List` is empty.
#
# Example:
#
#     my-head: head([1, 2, 3])   # => Optional(1)
#     empty-head: head([])       # => None
fun head(xs: List<a>) -> Optional<a>:
    if null(xs) then None else Optional(__Ludwig_List_unsafe_head(xs))

# Returns the specified `List` sans the `head` element wrapped in an
# `Optional`. Returns `None` if the `List` is empty.
#
# Example:
#
#     my-tail: tail([1, 2, 3])   # => Optional([2, 3])
#     singleton-tail: tail([1])  # => []
#     empty-tail: tail([])       # => None
fun tail(xs: List<a>) -> Optional<List<a>>:
    if null(xs) then None else Optional(__Ludwig_List_unsafe_tail(xs))

# Returns True if the `List` is empty, `False` otherwise.
#
# Example:
#
#     null([])     # => True
#     null([1, 2]) # => False
fun null(x: List<a>) -> Bool: __Ludwig_List_null(x)

# Append an element to the front of the specified `List`.
#
# Example:
#
#     list1: [2, 3]
#     list2: cons(1, list1) # => [1, 2, 3]
#     list3: const(1, [])   # => [1]
fun cons(x: a, xs: List<a>) -> List<a>: __Ludwig_List_cons(x, xs)

# Return a `List` of the first `n` elements of the specified
# `List`. Returns the original `List` if `length(xs) <= n`.
#
# Example:
#
#     take1: take(2, [1, 2, 3, 4, 5])  # => [1, 2]
#     take2: take(2, [1])              # => [1]
fun take(n: Int, xs: List<a>) -> List<a>:
  if n <= 0 then []
  else case uncons(xs) of
    | None             -> []
    | Optional (y, ys) -> cons(y, take(n - 1, ys))

# Return the original `List` without the first `n` elements. Returns
# the original `List` if `n` is negative and the empty `List` if
# `length(xs) <= n`.
#
# Example:
#
#     drop-1: drop(2, [1, 2, 3, 4, 5])   # => [3, 4, 5]
#     drop-2: drop(2, [1])               # => []
fun drop(n: Int, xs: List<a>) -> List<a>:
  if n <= 0 then xs
  else case tail(xs) of
    | Optional ys -> drop(n - 1, ys)
    | None        -> []

# Split the specified `List` into a tuple containing the `head` and
# `tail` of the `List` wrapped in an `Optional`. Returns `None` if the
# `List` is empty.
#
# Example:
#
#     uncons1: uncons([1, 2, 3])   # => Optional((1, [2, 3]))
#     uncons2: uncons([1])         # => Optional((1, []))
#     uncons3: uncons([])          # => None
fun uncons(xs: List<a>) -> Optional<(a, List<a>)>:
  case head(xs) of
    | Optional x -> Optional((x, drop(1, xs)))
    | None       -> None

# Returns a new `List` constructed by applying the specified function
# to each element in the provided `List`.
#
# Example:
#
#     my-list: map(fun(x): x * x, [1, 2, 3, 4, 5]   # => [1, 4, 9, 16, 25]
fun map(f: fun(b) -> a, xs: List<b>) -> List<a>:
  case uncons(xs) of
    | Optional (y, ys) -> cons(f(y), map(f, ys))
    | None             -> []

# Returns a new `List` containing the elements of the specified `List`
# where the provided predicate evaluates to `True`.
#
#
# Example:
#
#     my-filtered: filter(fun(x): x % 2 == 0, [1, 2, 3, 4, 5])   # => [2, 4]
fun filter(f: fun(a) -> Bool, xs: List<a>) -> List<a>:
  case uncons(xs) of
    | None             -> []
    | Optional (y, ys) -> if f(y) then cons(y, filter(f, ys))
                          else filter(f, ys)

# Return the Cartesian Product of two `List`s.
#
# Example:
#
#     my-product: cartesian-product([1, 2], ["a", "b"])   # => [(1, "a"), (1, "b"), (2, "a"), (2, "b")]
fun cartesian-product(xs: List<a>, ys: List<b>) -> List<(a, b)>:
  if null(ys) then []
  else case uncons(xs) of
    | Optional (z, zs) -> concat(map(fun(y): (z, y), ys), cartesian-product(zs, ys))
    | None             -> []

# Reduce a `List` by applying the given binary operation to an initial
# value and each element of the `List` from right to left.
#
# Example:
#
#     sum: fold(fun(x, y): x + y, 0, [1, 2, 3, 4, 5])   # => 15
fun fold(f: fun(b, a) -> b, z: b, xs: List<a>) -> b:
  case uncons(xs) of
    | None -> z
    | Optional (y, ys) -> fold(f, f(z, y), ys)

# Reduce a `List` by applying the given binary operation to each element of the
# `List` from right to left. The list must contain at least one element.
#
# Example:
#
#     sum: fold(fun(x, y): x + y, [1, 2, 3, 4, 5])   # => 15
fun fold1(f: fun(b, b) -> b, xs: List<b>) -> b:
    case uncons(xs) of
    | None -> error("At least one element is required")
    | Optional (y, ys) -> fold(f, y, ys)

# Retrieve a `List` element by index.
#
# Example:
#
#     x: safeElementAt(2, ["the", "quick", "brown", "fox"]         # => Optional("brown")
#     y: safeElementAt(negate(1), ["the", "quick", "brown", "fox"] # => None
#     z: safeElementAt(2, [])                                      # => None
#
# @arg i The element index. The `List` is indexed from 0.
# @arg list
# @return The element wrapped in an `Optional`. Returns `None` on an
# out of bounds index.
fun safeElementAt(i: Int, list: List<a>) -> Optional<a>:
  if i < 0 then None
  else case uncons(list) of
         | None             -> None
         | Optional (x, xs) -> if i == 0 then Optional(x)
                               else safeElementAt(i - 1, xs)

# Retrieve a `List` element by index.
#
# Example:
#
#     x: elementAt(2, ["the", "quick", "brown", "fox"] # => "brown"
#
# @arg i The element index. The `List` is indexed from 0.
# @arg list
#
# @return The element. An out of bounds index causes a compilation
# error.
fun elementAt(i: Int, list: List<a>) -> a:
  case safeElementAt(i, list) of
    | None -> error("Index out of bounds")
    | Optional elem -> elem

# Test if all elements of a `List` have the specified property.
#
# Example:
#
#     allEvens: all(fun(x): x % 2 == 0, [0, 2, 4, 6]) # => True
#     allOdds:  all(fun(x): x % 2 == 1, [1, 3, 4, 5]) # => False
#
# @return `True` if the `test` function returns `True` for all
# elements of `list`.
fun all(test: fun(a) -> Bool, list: List<a>) -> Bool:
  case uncons(list) of
    | None             -> True
    | Optional (x, xs) -> if test(x) then all(test, xs)
                          else False

# Test if any elements of a `List` have the specified property.
#
# Example:
#
#     anyOdds:  any(fun(x): x % 2 == 1, [0, 2, 4, 6]) # => False
#     anyEvens: any(fun(x): x % 2 == 0, [1, 3, 4, 5]) # => True
#
# @return `True` if the `test` function returns `True` for any
# elements of `list`.
fun any(test: fun(a) -> Bool, list: List<a>) -> Bool:
  case uncons(list) of
    | None             -> False
    | Optional (x, xs) -> if test(x) then True
                          else any(test, xs)

# Test if two List values are equal.
#
# Example:
#
#     x1: equal([], [], String.equal)                       # => True
#     x2: equal([1,2], [1,2], fun(x, y): x == y)            # => True
#     x3: equal([42], [1, 2], fun(x, y): x == y)            # => False
#     x4: equal(["foo", "bar"], [], String.equal)           # => False
#
# @arg this The first list to compare.
# @arg that The list to compare to `this`.
# @arg test The function used as the equality test for List elements.
# @return True if the lists are equal, otherwise False.
fun equal(this: List<a>, that: List<a>, test: fun(a, a) -> Bool) -> Bool:
  if length(this) != length(that) then False
  else
    case (uncons(this), uncons(that)) of
      | (None, None)                         -> True
      | (None, _)                            -> False
      | (_, None)                            -> False
      | (Optional (x, xs), Optional (y, ys)) -> if test(x, y) then equal(xs, ys, test) else False

# Insert a separator between elements in the list.
#
# Example:
#     ex1: List.intersperse(":", ["a", "b", "c"]) # => ["a", ":", "b", ":", "c"]
#
# @arg sep The separator.
# @arg xs The list of input elements.
fun intersperse(sep: a, xs: List<a>) -> List<a>:
  case uncons(xs) of
    | None             -> []
    | Optional (y, ys) -> if null(ys) then [y]
                          else concat([y, sep], intersperse(sep, ys))

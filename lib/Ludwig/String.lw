@language("no-prelude")

import Ludwig.List as List
import Ludwig.Int as Int

# Returns the length of the given 'String'
#
# Example:
#
#     x: length("foo") # => 3
fun length(string: String) -> Int: __Ludwig_String_length(string)

# Concatenate two strings.
#
# Example:
#
#     x: concat("hello", "world") # => "helloworld"
fun concat(a: String, b: String) -> String: __Ludwig_String_concat(a, b)

# String concatenation.
#
# Example:
#
#     x: "hello" ++ "world" # => "helloworld"
operator ++ infixr 5: concat

# Split a `String` on occurrences of a separator.
#
#
#
# Example:
#
#     split1: split("/", "1/2/3")   # => ["1", "2", "3"]
#     split2: split("", "hello")    # => ["h", "e", "l", "l", "o"]
#
# @arg separator The separator to split the source `String` on.
# @arg source The `String` to split.
# @return The `List` of sub-strings. `List` of characters if the
# `separator` is the empty string.
fun split(separator: String, source: String) -> List<String>: __Ludwig_String_split(separator, source)

# Convert the provided `String` to a `Int`
#
# Example:
#
#     x1: toInt("42")           # => Optional(42)
#     x2: toInt("-1")           # => Optional(-1)
#     x3: toInt("3.14")         # => None
#     x4: toInt("3 blind mice") # => None
#     x5: toInt("hello")        # => None
#
# @arg s The `String` to convert.
# @return An `Optional` with the converted `Int` or `None` if `s`
# cannot be converted.
fun toInt(s: String) -> Optional<Int>: __Ludwig_String_to_int(s)


# Convert the provided `String` to a `Float`.
#
# Example:
#
#     x1: toFloat("42")           # => Optional(42.0)
#     x2: toFloat("-1")           # => Optional(-1.0)
#     x3: toFloat("3.14")         # => Optional(3.14)
#     x4: toFloat("3 blind mice") # => None
#     x5: toFloat("hello")        # => None
#
# @arg s The `String` to convert.
# @return An `Optional` with the converted `Float` or `None` if `s`
# cannot be converted.
fun toFloat(s: String) -> Optional<Float>: __Ludwig_String_to_float(s)

# Test if a `String` is empty.
#
# Example:
#
#     x1: null("")    # => True
#     x2: null("foo") # => False
#
# @arg s The `String` to test.
# @return `True` if `s` is empty, `False` otherwise.
fun null(s: String) -> Bool: __Ludwig_String_null(s)

# Read a `String` from an UTF-8 encoded file.
#
# Example:
#
#     script: readFileUtf8("etc/script.sh")
#
# @arg filePath The path of the file to read. Relative paths are
#               considered relative to the directory where the
#               compiler is invoked, not the location of the
#               composition.
#
# @return The contents of the file.
fun readFileUtf8(filePath: String) -> String: __Ludwig_String_readFileUtf8(filePath)

# Get an environment variable. Returns `None` if the environment variable is not
# set.
#
# Example:
#
#     path: getEnv("PATH")
#
# @arg varName Name of the environment variable to get.
# @return The value of that environment variable, or `None`.
fun getEnv(varName: String) -> Optional<String>: __Ludwig_String_getEnv(varName)

# Print a string to stdout.
#
# Example:
#
#     x: print("Hello world!\n")
#
# @arg str The string to print.
fun print(str: String) -> (): __Ludwig_String_print(str)

# Test if two Strings are equal.
#
# Example:
#
#     x1: equal("foo", "bar") # => False
#     x2: equal("foo", "foo") # => True
#
# @return True if the two Strings are equal, False otherwise.
fun equal(x: String, y: String) -> Bool: __Ludwig_String_equal(x, y)

# Return the prefix of a String.
#
# Example usage:
#
#     ex1: String.take(3, "hello") # => "hel"
#     ex2: String.take(4, "foo")   # => "foo"
#
# @arg n The length of the prefix to return.
# @arg str The String to operate on.
# @return A String made up of the first `n` characters from `str`.
fun take(n: Int, str: String) -> String:
  let chars: split("", str)
  List.fold(concat, "", List.take(n, chars))

# Return the suffix of a String.
#
# Example usage:
#
#     ex1: String.drop(3, "foobar") # => "bar"
#     ex2: String.drop(4, "foo")    # => ""
#
# @arg n The length of the prefix to remove.
# @arg str The String to operate on.
# @return A String made up of `str` with the first `n` characters
#         removed.
fun drop(n: Int, str: String) -> String:
  let chars: split("", str)
  List.fold(concat, "", List.drop(n, chars))

# Test if a String starts with a given prefix.
#
# Example:
#
#     ex1: String.startsWith("foo", "helloworld")   # => False
#     ex2: String.startsWith("hello", "helloworld") # => True
#
# @arg prefix The prefix.
# @arg str The String to test.
# @return True is `str` begins with `prefix`; False otherwise.
fun startsWith(prefix: String, str: String) -> Bool:
  equal(take(length(prefix), str), prefix)


# Test if a String ends with a given suffix.
# Example:
#     ex1: String.endsWith("foo", "helloworld")   # => False
#     ex2: String.endsWith("world", "helloworld") # => True
#
# @arg suffix The suffix.
# @arg str The String to test.
# @return True is `str` ends with `suffix`; False otherwise.
fun endsWith(suffix: String, str: String) -> Bool:
  let len: Int.sub(length(str),length(suffix))
  equal(drop(len, str), suffix)

# Insert separator String in between elements in the list and concatenate the
# result.
#
# Example:
#     ex1: String.join(":", ["a", "b", "c"]) # => "a:b:c"
#
# @arg sep The separator.
# @arg xs The list of input Strings
fun join(sep: String, xs: List<String>) -> String:
  List.fold(concat, "", List.intersperse(sep, xs))

# Convert the provided `String` to `Bytes`.
#
# Example:
#
# ex1: String.toBytes("hello world")
#
# @arg str The string to convert.
# @return The string converted to UTF-8 encoded bytes.
fun toBytes(str: String) -> Bytes: __Ludwig_String_to_bytes(str)

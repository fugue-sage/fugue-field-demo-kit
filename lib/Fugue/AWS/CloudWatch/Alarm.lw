import Fugue.AWS as AWS
import Fugue.AWS.AutoScaling as AutoScaling
import Fugue.AWS.Internal.Validation as V
import Fugue.Core.AWS.CloudWatch as CloudWatch
import Ludwig.Dictionary as Dictionary

# `new` CloudWatch Alarm (Constructor)
#
# Call this constructor to create a new
# Fugue.Core.AWS.CloudWatch.Alarm value.
#
# Example:
#
#     composition
#     
#     import Fugue.AWS as AWS
#     import Fugue.AWS.CloudWatch as CloudWatch
#     import Fugue.AWS.SNS as SNS
#     
#     alerts: SNS.Topic.new {
#       name: "my-alerts",
#       region: AWS.Us-west-2,
#     }
#     
#     sendAlert: CloudWatch.Action.notifyTopic(alerts)
#     
#     alarm: CloudWatch.Alarm.new {
#       name: "example-alarm",
#       description: "1 minute WriteThrottleEvents > 0 for some-table",
#       okActions: [sendAlert],
#       alarmActions: [sendAlert],
#       insufficientDataActions: [sendAlert],
#       namespace: CloudWatch.Namespace.dynamodb,
#       metricName: "WriteThrottleEvents",
#       dimensions: {
#         "TableName": "some-table",
#       },
#       period: 60,
#       evaluationPeriods: 1,
#       threshold: 0.0,
#       statistic: CloudWatch.Sum,
#       comparisonOperator: CloudWatch.GreaterThanThreshold,
#       region: AWS.Us-west-2,
#     }
#
# @arg name The name of the alarm. Must be between 1 and 255
# characters in length.
#
# @arg description Optional description of the alarm. Must be between
# 1 and 255 characters in length.
#
# @arg actionsEnabled
#
# @arg okActions List of 1 to 5 actions to take when the alarm enters
# the "OK" state.
#
# @arg alarmActions List of 1 to 5 actions to take when the alarm
# enters the "ALARM" state.
#
# @arg insufficientDataActions List of 1 to 5 actions to take when
# the alarm enters the "INSUFFICIENT DATA" state.
#
# @arg metricName The name of the metric to monitor. Must be between 1
# and 255 characters in length.
#
# @arg namespace The namespace containing the targeted metric. Must be
# between 1 and 255 characters in length. See
# `Fugue.AWS.CloudWatch.Namespace` for predefined AWS namespaces.
#
# @arg statistic The metric statistic to monitor.
#
# @arg dimensions Dictionary mapping dimension names to values. Up to
# 10 dimensions may be specified.
#
# @arg period The number of seconds over which the statistic is
# applied. Must be greater than or equal to 60.
#
# @arg unit The unit applied to the statistic. The unit must be
# supported by the target metric. See the AWS docs for specific units
# supported by each metric.
#
# @arg evaluationPeriods The number of periods that the metric data is
# compared to the threshold.
#
# @arg threshold The threshold value to compare the metric data to.
#
# @arg comparisonOperator The operator to use when comparing metric
# data to the threshold.
#
# @arg region The region to create the alarm in.
fun new {
      name: String,
      description: Optional<String>,
      actionsEnabled: Optional<Bool>,
      okActions: Optional<List<CloudWatch.Action>>,
      alarmActions: Optional<List<CloudWatch.Action>>,
      insufficientDataActions: Optional<List<CloudWatch.Action>>,
      metricName: String,
      namespace: String,
      statistic: CloudWatch.Statistic,
      dimensions: Optional<Dictionary<String>>,
      period: Int,
      unit: Optional<CloudWatch.StandardUnit>,
      evaluationPeriods: Int,
      threshold: Float,
      comparisonOperator: CloudWatch.ComparisonOperator,
      region: AWS.Region
    } -> CloudWatch.Alarm:
  let dims: Optional.map(toDimensions, dimensions)
  let valid: V.concat [
    validateAlarmActions(alarmActions),
    validateDescription(description),
    validateDimensions(dims),
    validateEvaluationPeriods(evaluationPeriods),
    validateInsufficientDataActions(insufficientDataActions),
    validateMetricName(metricName),
    validateName(name),
    validateNamespace(namespace),
    validateOkActions(okActions),
    validatePeriod(period),
  ]
  case valid of
    | V.Fail err -> error("Invalid Alarm: " ++ err)
    | V.Success  -> CloudWatch.Alarm {
                      alarmName: name,
                      alarmDescription: description,
                      actionsEnabled: actionsEnabled,
                      okActions: okActions,
                      alarmActions: alarmActions,
                      insufficientDataActions: insufficientDataActions,
                      metricName: metricName,
                      namespace: namespace,
                      statistic: statistic,
                      dimensions: dims,
                      period: period,
                      unit: unit,
                      evaluationPeriods: evaluationPeriods,
                      threshold: threshold,
                      comparisonOperator: comparisonOperator,
                      region: region,
                    }

fun toDimensions(dimensions: Dictionary<String>) -> List<CloudWatch.Dimension>:
  let toDimension: fun(n):
    case Dictionary.lookup(n, dimensions) of
      | Optional value -> CloudWatch.Dimension {name: n, value: value}
  List.map(toDimension, Dictionary.keys(dimensions))


fun requiredStrLenValidator {field: String, min: Int, max: Int} -> (fun(String) -> V.Validation):
  fun(val): V.strLenValidator {field: "name", min: 1, max: 255}(Optional(val))

validateName: requiredStrLenValidator {field: "name", min: 1, max: 255}
validateDescription: V.strLenValidator {field: "description", min: 1, max: 255}
validateMetricName: requiredStrLenValidator {field: "metricName", min: 1, max: 255}
validateNamespace: requiredStrLenValidator {field: "namespace", min: 1, max: 255}

validateEvaluationPeriods: V.nonNegativeValidator("evaluationPeriods")

validateAlarmActions: V.listLenValidator {field: "alarmActions", min: 1, max: 5}
validateOkActions: V.listLenValidator {field: "okActions", min: 1, max: 5}
validateInsufficientDataActions: V.listLenValidator {field: "insufficientDataActions", min: 1, max: 5}

validateDimensions: V.listLenValidator {field: "dimensions", min: 1, max: 10}

fun validatePeriod(period: Int) -> V.Validation:
  if period < 60 then V.Fail "period must be at least 60 seconds"
  else V.Success

# This is the preferred interface for making AutoScaling Group
# resources with Fugue. The `AutoScalingGroup` and
# `LaunchConfiguration` modules comprise the bulk of the interface.
#
# If you want to manage an ASG with Fugue, the `new` function is the
# right place to start.

export
  default
  new
  type AutoScalingSpec

import Fugue.AWS.EC2 as EC2
import Fugue.AWS.Internal.Validation as .
import Fugue.AWS.Internal.Validation as V
import Fugue.Core.AWS.AutoScaling as AutoScaling
import Fugue.Core.AWS.Common as AWS
import Fugue.Core.AWS.ELB as ELB
import Ludwig.External as E

# `new` AutoScaling Group (Constructor)
#
# Call this constructor to create a new
# Fugue.Core.AWS.AutoScaling.AutoScalingGroup value.
#
# @arg spec An AutoScaling Group specification record.
# @return A
# Fugue.Core.AWS.AutoScaling.AutoScalingGroup value.
fun new(spec: AutoScalingSpec) -> AutoScaling.AutoScalingGroup:
  let valid: V.concat [
    validateMinSize(spec.minSize),
    validateMaxSize(spec.minSize, spec.maxSize),
    validateDefaultCoolDown(spec.defaultCooldown),
    Optional.mapUnpack(V.Success, validateHealthCheckGracePeriod, spec.healthCheckGracePeriod),
    validateHealthCheckGracePeriodIsRequiredWithElbHealthCheckType(spec.healthCheckType, spec.healthCheckGracePeriod),
    validatePlacementGroup(spec.placementGroup),
    validateSubnetsInSameVpc(spec.subnets),
    validateSubnetsAndSecurityGroupsInSameVpc(spec.subnets, spec.launchConfiguration),
    validateSubnetsAndElbsInSameVpc(spec.subnets, Optional.unpack([], spec.loadBalancers)),
    validateSecurityGroupsAndElbsInSameVpc(spec.launchConfiguration, Optional.unpack([], spec.loadBalancers)),
  ]
  case valid of
    | Success  -> AutoScaling.AutoScalingGroup(spec)
    | Fail err -> error(String.concat("Invalid AutoScalingSpec: ", err))

# AutoScaling Group Specification (Resource)
#
#
# This type of value specifies an AutoScalingGroup for the
# AutoScaling.`new`() constructor.
#
# Example:
#
#     AutoScaling.AutoScalingGroup.new {
#         subnets: demo-app-network.publicSubnets,
#         loadBalancers: [demo-app-elb],
#         minSize: 4,
#         maxSize: 4,
#         defaultCooldown: 300,
#         launchConfiguration: demo-app-lc,
#         healthCheckType: AutoScaling.Ec2,
#         tags: [demo-app-tag],
#         terminationPolicies: [AutoScaling.ClosestToNextInstanceHour],
#         enabledMetrics: [
#           AutoScaling.GroupInServiceInstances,
#           AutoScaling.GroupTotalInstances
#         ]
#     }
#
# @field minSize Minimum number of active instances in the AutoScaling Group. 
#
# @field maxSize Maximum number of active instances in the AutoScaling Group.
#
# @field defaultCooldown The default cooldown time, in seconds, to use
# between scaling events. Changes to the group size are not made
# during the cooldown period, no matter what the metrics might read.
#
# @field healthCheckType The type of health check to use for instances in the group.
#
# @field healthCheckGracePeriod The grace period to allow new
# instances in the group to go without a health check. Such instances
# are not put into service until their health check succeeds, and any
# health check failures on the instance are ignored.
#
# @field placementGroup The placement group in which to launch
# instances for the group.
#
# @field enabledMetrics Metrics to enable on the group.
#
# @field tags Key-value pair tags to assign to the group.
#
# @field terminationPolicies Policies to use for terminating instances
# in the group when scaling down.
#
# @field newInstancesProtectedFromScaleIn 
#
# @field launchConfiguration The launch configuration to use for new
# instances when scaling up.
#
# @field subnets The subnets in which to launch instances in the group.
#
# @field loadBalancers The load balancers with which to register
# instances in the group.
type AutoScalingSpec:
  minSize: Int
  maxSize: Int
  defaultCooldown: Int
  healthCheckType: AutoScaling.HealthCheck
  healthCheckGracePeriod: Optional<Int>
  placementGroup: Optional<String>
  enabledMetrics: Optional<List<AutoScaling.Metric>>
  tags: Optional<List<AWS.Tag>>
  terminationPolicies: Optional<List<AutoScaling.TerminationPolicy>>
  newInstancesProtectedFromScaleIn: Optional<Bool>
  launchConfiguration: AutoScaling.LaunchConfiguration
  subnets: List<EC2.Subnet>
  loadBalancers: Optional<List<ELB.LoadBalancer>>

# AutoScaling Group Specification (Default Values)
default: {
  minSize: 1,
  maxSize: 1,
  defaultCooldown: 300,
  healthCheckType: AutoScaling.Ec2,
  healthCheckGracePeriod: Optional(300),
  placementGroup: None,
  enabledMetrics: None,
  tags: None,
  terminationPolicies: None,
  newInstancesProtectedFromScaleIn: None,
  loadBalancers: None
}

# PRIVATE
fun allEqual(vpcs: List<EC2.Vpc>) -> Bool:
  case List.uncons(vpcs) of
    | Optional (h, t) -> List.all(fun(x): EC2.Vpc.equal(h, x), t)
    | None            -> True

validateMinSize: V.nonNegativeValidator("minSize")
validateDefaultCoolDown: V.nonNegativeValidator("defaultCooldown")
validateHealthCheckGracePeriod: V.nonNegativeValidator("healthCheckGracePeriod")

fun validateMaxSize(minSize: Int, maxSize: Int) -> V.Validation:
  if maxSize < minSize then
    V.Fail "maxSize must be greater than or equal to minSize"
  else
    V.Success

validatePlacementGroup: V.strLenValidator {field: "placementGroup", min: 1, max: 255}

fun validateHealthCheckGracePeriodIsRequiredWithElbHealthCheckType(healthCheckType: AutoScaling.HealthCheck, gracePeriod: Optional<Int>) -> V.Validation:
  case (healthCheckType, gracePeriod) of
    | (AutoScaling.Elb, None) -> V.Fail("healthCheckGracePeriod is required when healthCheckType is Elb")
    | _                       -> V.Success

fun removeExternals(lst: List<a>) -> List<a>: List.filter(fun(x): !(E.isExternal(x)), lst)

fun validateSubnetsInSameVpc(subnets: List<EC2.Subnet>) -> V.Validation:
  let netVpcs: List.map(fun(x): x.(EC2.Subnet).vpc, removeExternals(subnets))
  if allEqual(removeExternals(netVpcs)) then V.Success
  else V.Fail("Subnets must be in the same VPC")

fun validateSubnetsAndSecurityGroupsInSameVpc(subnets: List<EC2.Subnet>, lc: AutoScaling.LaunchConfiguration) -> V.Validation:
  if E.isExternal(lc) then V.Success
  else
    let sgs: lc.(AutoScaling.LaunchConfiguration).securityGroups
    let sgVpcs: List.map(fun(y): y.(EC2.SecurityGroup).vpc, removeExternals(sgs))
    let netVpcs: List.map(fun(x): x.(EC2.Subnet).vpc, removeExternals(subnets))
    if allEqual(removeExternals(List.concat(netVpcs, sgVpcs))) then V.Success
    else V.Fail("SecurityGroups and Subnets must be in the same VPC")

fun validateSubnetsAndElbsInSameVpc(subnets: List<EC2.Subnet>, elbs: List<ELB.LoadBalancer>) -> V.Validation:
  let elbNets: List.fold(List.concat, [], List.map(fun(x): x.(ELB.LoadBalancer).subnets, elbs))
  let vpcs: List.map(fun(x): x.(EC2.Subnet).vpc, removeExternals(List.concat(subnets, elbNets)))
  if allEqual(removeExternals(vpcs)) then V.Success
  else V.Fail("Subnets and LoadBalancers must be in the same VPC")

fun validateSecurityGroupsAndElbsInSameVpc(lc: AutoScaling.LaunchConfiguration, elbs: List<ELB.LoadBalancer>) -> V.Validation:
  if E.isExternal(lc) then V.Success
  else
    let elbNets: List.fold(List.concat, [], List.map(fun(x): x.(ELB.LoadBalancer).subnets, elbs))
    let elbVpcs: List.map(fun(x): x.(EC2.Subnet).vpc, elbNets)
    let sgs: lc.(AutoScaling.LaunchConfiguration).securityGroups
    let sgVpcs: List.map(fun(y): y.(EC2.SecurityGroup).vpc, removeExternals(sgs))
    if allEqual(removeExternals(List.concat(elbVpcs, sgVpcs))) then V.Success
    else V.Fail("SecurityGroups and LoadBalancers must be in the same VPC")

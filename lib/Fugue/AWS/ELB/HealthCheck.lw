# This is the preferred interface for creating ELB Health Checks with
# Fugue. The `new` function is the best place to start.

export
  type HealthCheckSpec
  type HttpSpec
  type TcpSpec
  type Spec
  default
  http
  https
  new
  ssl
  tcp

import Fugue.AWS.Internal.Validation as .
import Fugue.Core.AWS.ELB as ELB
import Ludwig.Int as Int

# `new` ELB Health Check (Constructor)
#
# Call this constructor to create a new Fugue.Core.AWS.ELB.HealthCheck
# value.
#
# You can use this function directly, but the `tcp`, `ssl`, `http`,
# and `https` functions in this module are preferred.
# 
# @arg spec An ELB Health Check specification record.
# @return A Fugue.Core.AWS.ELB.HealthCheck value.
fun new(spec: HealthCheckSpec) -> ELB.HealthCheck:
  case check(spec) of
    | Fail err -> error(String.concat("Invalid HealthCheck: ", err))
    | Success  ->  ELB.HealthCheck {
                     target: target {
                       protocol: spec.protocol,
                       port: spec.port,
                       path: spec.path,
                     },
                     interval: spec.interval,
                     timeout: spec.timeout,
                     unhealthyThreshold: spec.unhealthyThreshold,
                     healthyThreshold: spec.healthyThreshold,
                   }

# ELB Health Check Specification (Resource)
#
# This type of value specifies an ELB Health Check for the
# HealthCheck.`new`() constructor.
#
# @field interval The interval to wait between health check attempts.
#
# @field timeout The amount of time to wait for a response to a health
# check test before declaring the health check failed.
#
# @field unhealthyThreshold The number of failed health checks at
# which to mark an instance "unhealthy," which means that requests
# are _not_ forwarded to it.
#
# @field healthyThreshold The number of successful health checks at
# which to mark an instance "healthy," which means that requests
# _are_ forwarded to it.
#
# @field protocol The protocol to use for health check tests.
#
# @field port The port to use for health check tests.
#
# @field path The URL to use for HTTP health check tests. This is
# required when the health check protocol is HTTP or HTTPS.
type HealthCheckSpec:
  interval: Int
  timeout: Int
  unhealthyThreshold: Int
  healthyThreshold: Int
  protocol: ELB.Protocol
  port: Int
  path: Optional<String>

# ELB Health Check Specification (Default Values)
#
# Defaults taken from: 
# http://docs.aws.amazon.com/de_de/ElasticLoadBalancing/latest/DeveloperGuide/elb-healthchecks.html#health-check-configuration.
default: {
  interval: 30,
  timeout: 5,
  unhealthyThreshold: 2,
  healthyThreshold: 10,
}

# PRIVATE
# Test whether an integer value (`val`) is within the bounds
# given by `max` and `min`.
fun outOfBounds(val: Int, min: Int, max: Int) -> Bool: val < min || val > max

# PRIVATE
# Test whether an HTTP/HTTPS URL is a valid health check target, given the protocol
fun invalidTarget(spec: HealthCheckSpec) -> Bool:
  case spec.protocol of
   | ELB.HTTP  -> invalidPath(spec.path)
   | ELB.HTTPS -> invalidPath(spec.path)
   | _         -> False

# PRIVATE
# Test whether a string is a valid HTTP/S URL.
fun invalidPath(path: Optional<String>) -> Bool:
  case path of
    | None       -> True        # path is required for HTTP and HTTPS
    | Optional p -> let len: String.length(p)
                    (!(startsWithSlash(p))) || len < 1 || len > 1024

# PRIVATE
# Test whether a string starts with a '/' character.
fun startsWithSlash(s: String) -> Bool:
  case List.head(String.split("", s)) of
    | Optional "/" -> True
    | _            -> False

# PRIVATE
# Validate a health check specification.
fun check(spec: HealthCheckSpec) -> Validation:
 if outOfBounds(spec.healthyThreshold, 2, 10) then Fail "healthyThreshold must be >= 2 and <= 10"
 elif outOfBounds(spec.unhealthyThreshold, 2, 10) then Fail "unhealthyThreshold must be >= 2 and <= 10"
 elif outOfBounds(spec.interval, 2, 300) then Fail "interval must be >= 2 and <= 300"
 elif outOfBounds(spec.timeout, 2, 60) then Fail "timeout must be >= 2 and <= 60"
 elif outOfBounds(spec.port, 1, 65535) then Fail "port must be >= 1 and <= 65535"
 elif invalidTarget(spec) then Fail "path is required for HTTP and HTTPS checks, must start with a '/', and be between 1 and 1024 characters in length"
 else Success


# TODO: What follows seems to be API, but it is using a new set of
# idioms and I haven't found ready examples. The developer should
# document at a basic level when time allows.

# TODO: This entire module needs better examples.


type Spec<a>: {
  interval: Int,
  timeout: Int,
  unhealthyThreshold: Int,
  healthyThreshold: Int,
  port: Int,
  a
}

fun target(spec: {protocol: ELB.Protocol, port: Int, path: Optional<String>}) -> String:
  let proto: case spec.protocol of
               | ELB.TCP   -> "TCP"
               | ELB.SSL   -> "SSL"
               | ELB.HTTP  -> "HTTP"
               | ELB.HTTPS -> "HTTPS"
  let path: case spec.path of
              | None -> ""
              | Optional p -> p
  List.fold(String.concat, "", [proto, ":", Int.toString(spec.port), path])

type TcpSpec: Spec<{}>

# This is an alternative constructor for HealthChecks.
#
# Example usage:
#
#     healthCheck: ELB.HealthCheck.tcp {
#         port: 3000,
#         interval: 15,
#         timeout: 3,
#         unhealthyThreshold: 3,
#         healthyThreshold: 3
#     }
fun tcp(spec: TcpSpec) -> ELB.HealthCheck:
  new(spec with {protocol: ELB.TCP, path: None})

fun ssl(spec: TcpSpec) -> ELB.HealthCheck:
  new(spec with {protocol: ELB.SSL, path: None})

type HttpSpec: Spec<{path: String}>

fun http(spec: HttpSpec) -> ELB.HealthCheck:
  new(spec with {protocol: ELB.HTTP, path: Optional(spec.path)})

fun https(spec: HttpSpec) -> ELB.HealthCheck:
  new(spec with {protocol: ELB.HTTPS, path: Optional(spec.path)})

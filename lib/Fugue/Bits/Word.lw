export
  type Word
  and
  eq
  fromInt
  toString

import Fugue.Bits.Byte as Byte
import Ludwig.Int as Int

# A Word is four bytes.
type Word:
  _0: Byte.Byte
  _1: Byte.Byte
  _2: Byte.Byte
  _3: Byte.Byte

# Bitwise `and` of two Words.
Word and(Word x, Word y):
  {
    _0: Byte.and(x._0, y._0),
    _1: Byte.and(x._1, y._1),
    _2: Byte.and(x._2, y._2),
    _3: Byte.and(x._3, y._3)
  }

# Unsigned bitwise left shift.
Int lshift(Int x, Int shift): x * (2 ^ shift)

# Unsigned bitwise right shift.
Int rshift(Int x, Int shift): x / (2 ^ shift)

max_word: 4294967295             # (2 ^ 32) - 1

# Convert an Int to a Word.
#
# @arg x The Int to convert. Must be between 0 and 4294967295.
# @return The Word representation of x.
#
Word fromInt(Int x):
  let shift: fun(n): 24 - (n * 8)
  # Mask off everything in `x` but byte `n` and convert to a `Byte`.
  let byte: fun(n):
    Byte.fromInt(rshift(lshift(x, shift(n)) % (max_word + 1), 24))

  if x > max_word || x < 0 then
    error(String.concat("Words must be between 0 and ", Int.toString(max_word)))
  else {
    _0: byte(0),
    _1: byte(1),
    _2: byte(2),
    _3: byte(3)
  }

# Convert a Word to a String.
#
# @arg x The Word to convert.
# @return The binary representation of the Word as a String
#
# Example:
#
#    bits: Word.toString(Word.fromInt(255))  # => "00000000000000000000000011111111"
#
String toString(Word x):
  let bytes: [x._3, x._2, x._1, x._0]
  List.fold(String.concat, "", List.map(Byte.toString, bytes))

# Compare two Words for equality.
#
# @arg x
# @arg y
# @return True if x and y are equal. False otherwise.
#
Bool eq(Word x, Word y):
  Byte.eq(x._0, y._0) &&
  Byte.eq(x._1, y._1) &&
  Byte.eq(x._2, y._2) &&
  Byte.eq(x._3, y._3)
